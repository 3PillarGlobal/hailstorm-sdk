require 'hailstorm'
require 'hailstorm/model'
require 'hailstorm/behavior/loggable'
require 'hailstorm/behavior/clusterable'
require 'hailstorm/behavior/provisionable'
require 'hailstorm/behavior/sshable'
require 'hailstorm/support/ssh'
require 'hailstorm/support/amazon_account_cleaner'
require 'hailstorm/support/java_installer'
require 'hailstorm/support/jmeter_installer'
require 'hailstorm/support/waiter'
require 'hailstorm/support/aws_adapter'

# Represents state and behavior for Amazon Web Services (AWS) cluster
# @author Sayantam Dey
class Hailstorm::Model::AmazonCloud < ActiveRecord::Base
  include Hailstorm::Behavior::Loggable
  include Hailstorm::Behavior::Clusterable
  include Hailstorm::Behavior::Provisionable
  include Hailstorm::Behavior::SSHable

  before_validation :set_defaults

  validates_presence_of :access_key, :secret_key, :region

  validates_presence_of :agent_ami, if: ->(r) { r.active? && r.ssh_port && r.ssh_port != Defaults::SSH_PORT }

  validate :identity_file_exists, if: proc { |r| r.active? && r.autogenerated_ssh_key? }

  validate :identity_file_ok, if: proc { |r| r.active? && !r.autogenerated_ssh_key? && r.ssh_identity }

  before_save :assign_vpc_subnet, if: ->(r) { r.active? && r.vpc_subnet_id.blank? }

  before_save :set_availability_zone, if: proc { |r| r.active? }

  before_save :create_security_group, if: proc { |r| r.active? }

  before_save :create_agent_ami, if: proc { |r| r.active? && r.agent_ami.nil? }

  after_destroy :cleanup

  # (see Hailstorm::Behavior::Clusterable#slug)
  def slug
    @slug ||= "#{self.class.name.demodulize.titlecase}, region: #{self.region}"
  end

  # (see Hailstorm::Behavior::Clusterable#public_properties)
  def public_properties
    columns = [:region]
    self.attributes.symbolize_keys.slice(*columns)
  end

  # Purges the Amazon accounts used of Hailstorm related artifacts
  def purge(cleaner = nil)
    logger.debug { "#{self}.#{__method__}" }
    cleaner ||= Hailstorm::Support::AmazonAccountCleaner.new(client_factory: client_factory,
                                                             region_code: self.region)
    cleaner.cleanup
    self.update_column(:agent_ami, nil)
  end

  def self.round_off_max_threads_per_agent(computed)
    pivot = if computed <= 10
              5
            else
              computed <= 50 ? 10 : 50
            end
    (computed.to_f / pivot).round * pivot
  end

  # Helper methods for load agents
  module AgentHelper

    # Creates an load agent AMI with all required packages pre-installed and
    # starts requisite number of instances
    def setup(force = false)
      logger.debug { "#{self.class}##{__method__}" }
      self.save! if self.changed? || self.new_record?
      return unless self.active? || force

      provision_agents
    end

    # Delete SSH key-pair and identity once all load agents have been terminated
    # (see Hailstorm::Behavior::Clusterable#cleanup)
    def cleanup
      logger.debug { "#{self.class}##{__method__}" }
      return unless self.active? && self.autogenerated_ssh_key? && self.load_agents(true).empty?

      key_pair_id = key_pair_client.find(name: self.ssh_identity)
      return unless key_pair_id

      key_pair_client.delete(key_pair_id: key_pair_id)
      FileUtils.safe_unlink(identity_file_path)
    end

    # start the agent and update agent ip_address and identifier
    def start_agent(load_agent)
      return if load_agent.running?

      instance = instance_client.find(instance_id: load_agent.identifier) unless load_agent.identifier.nil?
      if instance
        instance = restart_agent(instance_id: instance.id, stopped: instance.stopped?)
      else
        instance = create_agent
        instance_name = "#{self.project.project_code}-#{load_agent.class.name.underscore}-#{load_agent.id}"
        instance_client.tag_name(resource_id: instance.id, name: instance_name)
      end

      # copy attributes
      load_agent.identifier = instance.instance_id
      load_agent.public_ip_address = instance.public_ip_address
      load_agent.private_ip_address = instance.private_ip_address
    end

    # stop the load agent
    def stop_agent(load_agent)
      if load_agent.identifier
        agent_ec2_instance = instance_client.find(instance_id: load_agent.identifier)
        if agent_ec2_instance.running?
          logger.info("Stopping agent##{load_agent.identifier}...")
          instance_client.stop(instance_id: load_agent.identifier)
          wait_for("#{agent_ec2_instance.id} to stop",
                   err_attrs: { region: self.region }) { instance_client.stopped?(agent_ec2_instance) }
        end
      else
        logger.warn('Could not stop agent as identifier is not available')
      end
    end

    # Start load agents if not started
    # (see Hailstorm::Behavior::Clusterable::LoadAgentHelper#before_generate_load)
    def before_generate_load
      logger.debug { "#{self.class}##{__method__}" }
      self.load_agents.where(active: true).each do |agent|
        unless agent.running?
          start_agent(agent)
          agent.save!
        end
      end
    end

    # Process the suspend option. Must be specified as {:suspend => true}
    # @param [Hash] options
    # (see Hailstorm::Behavior::Clusterable::LoadAgentHelper#after_stop_load_generation)
    def after_stop_load_generation(options = nil)
      logger.debug { "#{self.class}##{__method__}" }
      suspend = (options.nil? ? false : options[:suspend])
      return unless suspend

      self.load_agents.where(active: true).each do |agent|
        next unless agent.running?

        stop_agent(agent)
        agent.public_ip_address = nil
        agent.save!
      end
    end

    # Terminate load agent
    # (see Hailstorm::Behavior::Provisionable#before_destroy_load_agent)
    def before_destroy_load_agent(load_agent)
      agent_ec2_instance = instance_client.find(instance_id: load_agent.identifier)
      if agent_ec2_instance
        logger.info("Terminating agent##{load_agent.identifier}...")
        instance_client.terminate(instance_id: agent_ec2_instance.id)
        logger.debug { "Waiting for #{agent_ec2_instance.id} to terminate..." }
        wait_for("#{agent_ec2_instance.id} on #{self.region} region to terminate") do
          instance_client.terminated?(instance_id: agent_ec2_instance.id)
        end
      else
        logger.warn("Agent ##{load_agent.identifier} does not exist on EC2")
      end
    end

    def required_load_agent_count(jmeter_plan)
      if self.respond_to?(:max_threads_per_agent) && jmeter_plan.num_threads > self.max_threads_per_agent
        (jmeter_plan.num_threads.to_f / self.max_threads_per_agent).ceil
      else
        1
      end
    end

    def restart_agent(instance_id:, stopped:)
      if stopped
        logger.info("Restarting agent##{instance_id}...")
        instance_client.start(instance_id: instance_id)
      end

      wait_for("agent##{instance_id} to restart",
               err_attrs: { region: self.region }) { instance_client.running?(instance_id: instance_id) }

      instance_client.find(instance: instance_id)
    end

    def create_agent
      logger.info("Starting new agent on #{self.region}...")
      security_group = find_security_group
      create_ec2_instance(new_ec2_instance_attrs(self.agent_ami, [security_group.id]))
    end
  end

  include AgentHelper

  # @param [String] instance_type
  # @return [Integer]
  def self.calc_max_threads_per_instance(instance_type:)
    iclass, itype = instance_type.split(/\./).collect(&:to_sym)
    iclass ||= :t3a
    itype ||= :small
    itype_index = Defaults::KNOWN_INSTANCE_TYPES.find_index(itype).to_i - 2 # :small is 0th index, :nano is -2
    itype_factor = Defaults::INSTANCE_TYPE_SCALE_FACTOR**itype_index
    iclass_factor = Defaults::INSTANCE_CLASS_SCALE_FACTOR[iclass] || Defaults::INSTANCE_CLASS_SCALE_FACTOR[:t3a]
    self.round_off_max_threads_per_agent(iclass_factor * itype_factor * Defaults::MIN_THREADS_ONE_AGENT)
  end

  ######################### PRIVATE METHODS ####################################
  private

  def set_defaults
    self.security_group = Defaults::SECURITY_GROUP if self.security_group.blank?
    self.user_name ||= Defaults::SSH_USER
    self.instance_type ||= Defaults::INSTANCE_TYPE
    self.max_threads_per_agent ||= default_max_threads_per_agent
    self.region ||= Defaults::EC2_REGION
    return if self.ssh_identity

    self.ssh_identity = [Defaults::SSH_IDENTITY, self.project.project_code].join('_')
    self.autogenerated_ssh_key = true
  end

  def client_factory
    Hailstorm::Support::AwsAdapter.clients(aws_config)
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::KeyPairClient]
  def key_pair_client
    @key_pair_client ||= client_factory.key_pair_client
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::InstanceClient]
  def instance_client
    @instance_client ||= client_factory.instance_client
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::SecurityGroupClient]
  def security_group_client
    @security_group_client ||= client_factory.security_group_client
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::Ec2Client]
  def ec2_client
    @ec2_client ||= client_factory.ec2_client
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::AmiClient]
  def ami_client
    @ami_client ||= client_factory.ami_client
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::SubnetClient]
  def subnet_client
    @subnet_client ||= client_factory.subnet_client
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::VpcClient]
  def vpc_client
    @vpc_client ||= client_factory.vpc_client
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::InternetGatewayClient]
  def internet_gateway_client
    @internet_gateway_client ||= client_factory.internet_gateway_client
  end

  # @return [Hailstorm::Behavior::AwsAdaptable::RouteTableClient]
  def route_table_client
    @route_table_client ||= client_factory.route_table_client
  end

  def aws_config
    @aws_config ||= {
      access_key_id: self.access_key,
      secret_access_key: self.secret_key,
      region: self.region,
      max_retries: 3,
      logger: logger
    }
  end

  # Sets the first available zone based on configured region
  # only if the project is configured in master slave mode
  def set_availability_zone
    logger.debug { "#{self.class}##{__method__}" }
    return unless self.zone.blank? && self.project.master_slave_mode?

    self.zone = ec2_client.first_available_zone
  end

  def default_max_threads_per_agent
    self.class.calc_max_threads_per_instance(instance_type: self.instance_type)
  end

  # Helper methods for SSH identity
  module IdentityHelper
    def identity_file_exists
      return if File.exist?(identity_file_path)

      key_pair_id = key_pair_client.find(name: self.ssh_identity)
      if key_pair_id
        key_pair_client.delete(key_pair_id: key_pair_id)
        logger.warn("Unusable key_pair '#{key_pair_id}' was deleted")
      end

      create_key_pair
    end

    def create_key_pair
      logger.debug { "Creating #{self.ssh_identity} key_pair..." }
      key_pair = key_pair_client.create(name: self.ssh_identity)
      kp_path = identity_file_path
      File.open(kp_path, 'w') do |file|
        file.print(key_pair.private_key)
      end

      secure_identity_file(kp_path)
    end

    def identity_file_name
      [File.basename(self.ssh_identity).gsub(/\.pem/, ''), self.region].join('_').concat('.pem', '')
    end
  end

  # Helper methods for Security Groups
  module SecurityGroupHelper

    def find_vpc
      ec2_client.find_vpc(subnet_id: self.vpc_subnet_id) if self.vpc_subnet_id
    end

    def find_security_group(vpc_id: nil)
      vpc_id ||= find_vpc
      security_group_client.find(name: self.security_group, vpc_id: vpc_id)
    end

    def create_security_group
      logger.debug { "#{self.class}##{__method__}" }
      vpc_id = find_vpc
      security_group = find_security_group(vpc_id: vpc_id)
      unless security_group
        logger.info("Creating #{self.security_group} security group on #{self.region}...")
        security_group = security_group_client.create(name: self.security_group,
                                                      description: Defaults::SECURITY_GROUP_DESC,
                                                      vpc_id: vpc_id)

        # allow SSH from anywhere
        port_or_range = self.ssh_port || Defaults::SSH_PORT
        security_group_client.authorize_ingress(group_id: security_group.group_id,
                                                protocol: :tcp,
                                                port_or_range: port_or_range,
                                                cidr: :anywhere)

        # allow incoming TCP & UDP to any port within the group
        %i[tcp udp].each do |proto|
          security_group_client.authorize_ingress(group_id: security_group.group_id,
                                                  protocol: proto,
                                                  port_or_range: 0..65_535)
        end

        security_group_client.allow_ping(group_id: security_group.group_id) # allow ICMP from anywhere
      end

      security_group
    end
  end

  # Helper methods for EC2 instances
  module InstanceHelper


    # Builds the Hash attributes for creating a new EC2 instance.
    # @param [String] ami_id
    # @param [Array] security_group_ids
    # @return [Hash]
    def new_ec2_instance_attrs(ami_id, security_group_ids)
      attrs = { image_id: ami_id, key_name: self.ssh_identity, security_group_ids: security_group_ids,
                instance_type: self.instance_type, subnet_id: self.vpc_subnet_id }
      attrs[:availability_zone] = self.zone if self.zone
      attrs
    end

    def perform_instance_checks(instance)
      logger.info { "Instance #{instance.id} in #{self.region} running, waiting for system checks..." }
      wait_for("#{instance.id} to start and successful system checks",
               timeout_sec: 600,
               sleep_duration: 10,
               err_attrs: {region: self.region}) { instance_client.ready?(instance_id: instance.id) }
    rescue Exception => ex
      logger.warn("Failed to create new instance: #{ex.message}")
      raise(ex)
    end

    def ensure_ssh_connectivity(instance)
      logger.info { "Ensuring SSH access to Instance #{instance.id} in #{self.region}..." }
      return if Hailstorm::Support::SSH.ensure_connection(instance.public_ip_address, self.user_name, ssh_options)

      raise(Hailstorm::Exception, "Failed to connect to #{instance.id}")
    end

    def terminate_instance(instance)
      logger.debug { instance.inspect }
      instance_client.terminate(instance_id: instance.id)
      logger.debug { "status: #{instance.status}" }
      wait_for("Instance #{instance.id} to terminate",
               err_attrs: { region: self.region }) { instance_client.terminated?(instance_id: instance.id) }
    end

    # Creates a new EC2 instance and returns the instance once it passes all checks.
    # @param [Hash] attrs EC2 instance attributes
    # @return [Hailstorm::Behavior::AwsAdaptable::Instance]
    def create_ec2_instance(attrs)
      instance = instance_client.create(attrs)
      perform_instance_checks(instance)
      instance = instance_client.find(instance_id: instance.id)
      ensure_ssh_connectivity(instance)
      instance
    end
  end

  # Helper methods for installers in AMIs
  module InstallerHelper

    # install JMeter to self.user_home
    def install_jmeter(ssh)
      logger.info { "Installing JMeter for #{self.region} AMI..." }
      installer = Hailstorm::Support::JmeterInstaller.create
                                                     .with(:download_url, self.project.custom_jmeter_installer_url)
                                                     .with(:user_home, self.user_home)
                                                     .with(:jmeter_version, self.project.jmeter_version)

      installer.install do |instr|
        ssh.exec!(instr)
      end
    end

    # install JAVA
    def install_java(ssh)
      logger.info { "Installing Java for #{self.region} AMI..." }
      output = ''
      Hailstorm::Support::JavaInstaller.create.install do |instr|
        on_data = lambda do |data|
          output << data
          logger.debug { data }
        end
        instr_success = ssh_channel_exec_instr(ssh, instr, on_data)
        raise(Hailstorm::JavaInstallationException.new(self.region, output)) unless instr_success
      end

      verify_java(ssh)
      output
    end

    # Executes the instruction on an SSH channel
    # @param ssh [Net::SSH::Connection::Session] open ssh session
    # @param instr [String] instruction to execute
    # @param on_data [Proc] handler for data on stdout
    # @param on_error [Proc] handler for data on stderr
    # @return [Boolean] true if the instruction succeeded, false otherwise
    def ssh_channel_exec_instr(ssh, instr, on_data, on_error = nil)
      instr_success = false
      channel = ssh.open_channel do |chnl|
        chnl.exec(instr) do |ch, success|
          instr_success = success
          ch.on_data { |_c, data| on_data.call(data) }
          ch.on_extended_data { |_c, _t, data| (on_error || on_data).call(data) }
        end
      end
      channel.wait
      instr_success
    end

    # Verifies Java is installed
    # @param ssh [Net::SSH::Connection::Session] open ssh session
    def verify_java(ssh)
      cmd_out = ''
      success = ssh_channel_exec_instr(ssh, 'java -version', ->(data) { cmd_out << data })
      logger.debug { cmd_out }
      raise(Hailstorm::JavaInstallationException.new(self.region, cmd_out)) unless success && cmd_out =~ /version/
    end
  end

  # Helper methods for creating agent AMI
  module AmiHelper

    # creates the agent ami
    def create_agent_ami
      return unless ami_creation_needed?

      # AMI does not exist
      logger.info("Creating agent AMI for #{self.region}...")
      security_group = find_security_group
      clean_instance = nil
      begin
        clean_instance = create_ec2_instance(new_ec2_instance_attrs(base_ami, [security_group.id]))
        build_ami(clean_instance)
      rescue Exception => ex
        logger.error("Failed to create instance on #{self.region}: #{ex.message}, terminating temporary instance...")
        raise(ex)
      ensure
        terminate_instance(clean_instance) if clean_instance
      end
    end

    # @return [Boolean] true if agent AMI should be created
    def ami_creation_needed?
      self.active? && self.agent_ami.nil? && check_for_existing_ami.nil?
    end

    # Check if this region already has the Hailstorm AMI and return the identifier.
    # @return [String] AMI id
    def check_for_existing_ami
      regexp = Regexp.compile(ami_id)
      logger.info("Searching available AMI on #{self.region}...")
      ex_ami = ami_client.find_self_owned(ami_name_regexp: regexp)
      if ex_ami
        self.agent_ami = ex_ami.id
        logger.info("Using AMI #{self.agent_ami} for #{self.region}...")
      end

      ex_ami
    end

    # Build the AMI from a running instance
    def build_ami(instance)
      provision(instance)
      logger.info { "Finalizing changes for #{self.region} AMI..." }
      self.agent_ami = register_hailstorm_ami(instance)
      logger.info { "New AMI##{self.agent_ami} on #{self.region} created successfully, cleaning up..." }
    end

    # Install everything
    def provision(instance)
      Hailstorm::Support::SSH.start(instance.public_ip_address, self.user_name, ssh_options) do |ssh|
        install_java(ssh)
        install_jmeter(ssh)
      end
    end

    # Create and register the AMI
    # @param [Hailstorm::Behavior::AwsAdaptable::Instance] instance
    # @return [String] AMI Id of the just registered AMI
    def register_hailstorm_ami(instance)
      new_ami_id = ami_client.register_ami(
        name: ami_id,
        instance_id: instance.instance_id,
        description: 'AMI for distributed performance testing with Hailstorm'
      )

      begin
        wait_for("Hailstorm AMI #{ami_id} on #{self.region} to be created") do
          ami_client.available?(ami_id: new_ami_id)
        end
      rescue Hailstorm::Exception
        ami = ami_client.find(ami_id: new_ami_id)
        raise(Hailstorm::AmiCreationFailure.new(self.region, ami.state_reason))
      end

      new_ami_id
    end

    # Architecture as per instance_type - everything is 64-bit.
    def arch(internal = false)
      internal ? '64-bit' : 'x86_64'
    end

    # The AMI ID to search for and create
    def ami_id
      [Defaults::AMI_ID,
       "j#{self.project.jmeter_version}"]
        .push(self.project.custom_jmeter_installer_url ? self.project.project_code : nil)
        .push(arch)
        .push(Hailstorm.production? ? nil : Hailstorm.env)
        .compact
        .join('-')
    end

    # Base AMI to use to create Hailstorm AMI based on the region and instance_type
    # @return [String] Base AMI ID
    def base_ami
      region_base_ami_map[self.region][arch(true)]
    end

    # Static map of regions, architectures and AMI ID of latest stable Ubuntu LTS AMIs
    # On changes to this map, be sure to execute ``rspec -t integration``.
    ARCH_64 = '64-bit'.freeze

    def region_base_ami_map
      @region_base_ami_map ||= [
        { region: 'us-east-1',      ami: 'ami-07ebfd5b3428b6f4d' }, # US East (Virginia)
        { region: 'us-east-2',      ami: 'ami-0fc20dd1da406780b' }, # US East (Ohio)
        { region: 'us-west-1',      ami: 'ami-03ba3948f6c37a4b0' }, # US West (N. California)
        { region: 'us-west-2', 	    ami: 'ami-0d1cd67c26f5fca19' }, # US West (Oregon)
        { region: 'ca-central-1',   ami: 'ami-0d0eaed20348a3389' }, # Canada (Central)
        { region: 'eu-west-1',      ami: 'ami-035966e8adab4aaad' }, # EU (Ireland)
        { region: 'eu-central-1',   ami: 'ami-0b418580298265d5c' }, # EU (Frankfurt)
        { region: 'eu-west-2',      ami: 'ami-006a0174c6c25ac06' }, # EU (London)
        { region: 'ap-northeast-1', ami: 'ami-07f4cb4629342979c' }, # Asia Pacific (Tokyo)
        { region: 'ap-southeast-1', ami: 'ami-09a4a9ce71ff3f20b' }, # Asia Pacific (Singapore)
        { region: 'ap-southeast-2', ami: 'ami-02a599eb01e3b3c5b' }, # Asia Pacific (Sydney)
        { region: 'ap-northeast-2', ami: 'ami-0cd7b0de75f5a35d1' }, # Asia Pacific (Seoul)
        { region: 'ap-south-1',     ami: 'ami-0620d12a9cf777c87' }, # Asia Pacific (Mumbai)
        { region: 'sa-east-1',      ami: 'ami-05494b93950efa2fd' }  # South America (Sao Paulo)
      ].reduce({}) { |s, e| s.merge(e[:region] => { ARCH_64 => e[:ami] }) }
    end
  end

  # Create VPC and associated infrastructure
  module VpcHelper
    def assign_vpc_subnet
      self.vpc_subnet_id = subnet_client.find(name_tag: Defaults::SUBNET_NAME) || create_hailstorm_subnet
    end

    # https://docs.aws.amazon.com/vpc/latest/userguide/vpc-subnets-commands-example.html
    # @return [String] subnet_id
    def create_hailstorm_subnet
      created_vpc_id = create_hailstorm_vpc
      hailstorm_subnet_id = subnet_client.create(vpc_id: created_vpc_id, cidr: Defaults::CIDR_BLOCK)
      wait_for("#{Defaults::SUBNET_NAME} to be available") { subnet_client.available?(subnet_id: hailstorm_subnet_id) }

      subnet_client.tag_name(resource_id: hailstorm_subnet_id, name: Defaults::SUBNET_NAME)
      subnet_client.modify_attribute(subnet_id: hailstorm_subnet_id, map_public_ip_on_launch: true)
      logger.info { "Created #{Defaults::SUBNET_NAME} subnet - #{hailstorm_subnet_id}" }
      make_subnet_public(vpc_id: created_vpc_id, subnet_id: hailstorm_subnet_id)
      hailstorm_subnet_id
    end

    # @return [String] vpc_id
    def create_hailstorm_vpc
      vpc_tag_name = "#{Defaults::VPC_NAME}_#{Hailstorm.env}"
      hailstorm_vpc_id = vpc_client.create(cidr: Defaults::CIDR_BLOCK)
      wait_for("#{vpc_tag_name} VPC to be available") { vpc_client.available?(vpc_id: hailstorm_vpc_id) }

      vpc_client.modify_attribute(vpc_id: hailstorm_vpc_id, enable_dns_support: true)
      vpc_client.modify_attribute(vpc_id: hailstorm_vpc_id, enable_dns_hostnames: true)
      vpc_client.tag_name(resource_id: hailstorm_vpc_id, name: vpc_tag_name)
      logger.info { "Created #{vpc_tag_name} VPC - #{hailstorm_vpc_id}" }
      hailstorm_vpc_id
    end

    # @param [String] vpc_id
    # @param [String] subnet_id
    def make_subnet_public(vpc_id:, subnet_id:)
      igw_id = internet_gateway_client.create
      internet_gateway_client.tag_name(resource_id: igw_id, name: Defaults::VPC_NAME)
      internet_gateway_client.attach(igw_id: igw_id, vpc_id: vpc_id)
      logger.info { "Created Internet Gateway #{igw_id}" }

      route_table_id = route_table_client.main_route_table(vpc_id: vpc_id) || route_table_client.create(vpc_id: vpc_id)
      route_table_client.create_route(route_table_id: route_table_id, cidr: '0.0.0.0/0', internet_gateway_id: igw_id)
      wait_for("Route table #{route_table_id} default route to be created") do
        route_table_client.routes(route_table_id: route_table_id).all? { |route| route.active? }
      end

      route_table_client.associate_with_subnet(route_table_id: route_table_id, subnet_id: subnet_id)
      logger.info { "Created routing table with default route #{route_table_id}" }
    end
  end

  include Hailstorm::Support::Waiter
  include IdentityHelper
  include SecurityGroupHelper
  include InstanceHelper
  include InstallerHelper
  include AmiHelper
  include VpcHelper

  # EC2 default settings
  class Defaults
    AMI_ID              = '3pg-hailstorm'.freeze
    SECURITY_GROUP      = 'Hailstorm'.freeze
    SECURITY_GROUP_DESC = 'Allows SSH traffic from anywhere and all internal TCP, UDP and ICMP traffic'.freeze
    SSH_USER            = 'ubuntu'.freeze
    SSH_IDENTITY        = 'hailstorm'.freeze
    INSTANCE_TYPE       = 'm5a.large'.freeze
    INSTANCE_CLASS_SCALE_FACTOR = { t2: 2, t3: 2, t3a: 2, m4: 4, m5: 5,
                                    m5a: 6, m5ad: 7, m5d: 8, m5dn: 9, m5n: 10 }.freeze
    INSTANCE_TYPE_SCALE_FACTOR = 2
    KNOWN_INSTANCE_TYPES = [:nano, :micro, :small, :medium, :large, :xlarge,
                            '2xlarge'.to_sym, '4xlarge'.to_sym, '8xlarge'.to_sym, '10xlarge'.to_sym, '12xlarge'.to_sym,
                            '16xlarge'.to_sym, '24xlarge'.to_sym, :metal].freeze

    MIN_THREADS_ONE_AGENT = 10
    SSH_PORT = Hailstorm::Behavior::SSHable::Defaults::SSH_PORT
    EC2_REGION = 'us-east-1'.freeze
    VPC_NAME = 'hailstorm'.freeze
    CIDR_BLOCK = '10.0.0.0/16'.freeze
    SUBNET_NAME = "#{VPC_NAME} public".freeze
  end
end

#
# ExecutionCycle model
# @author Sayantam Dey

require 'erubis/engine/eruby'
require 'zip/filesystem'

require 'hailstorm/model'
require 'hailstorm/model/project'
require 'hailstorm/model/master_agent'
require 'hailstorm/model/client_stat'
require 'hailstorm/model/target_stat'
require 'hailstorm/model/jmeter_plan'
require 'hailstorm/support/report_builder'

# This is a representation of one test run. A single test run can be as simple as one JMeter plan executed on a single
# cluster and more complicated with multiple JMeter plans and/or multiple clusters.
class Hailstorm::Model::ExecutionCycle < ActiveRecord::Base
  belongs_to :project

  has_many :client_stats, dependent: :destroy

  has_many :target_stats, dependent: :destroy

  before_create :set_defaults

  # Collects the statistics generated by the load generating cluster
  # @param [Hailstorm::Behavior::Clusterable] cluster_instance
  def collect_client_stats(cluster_instance)
    logger.debug { "#{self.class}.#{__method__}" }
    jmeter_plan_results_map = {}
    result_mutex = Mutex.new
    llp = local_log_path

    visit_collection(cluster_instance.master_agents.where(active: true)) do |master|
      result_file_name = master.result_for(self, llp)
      result_file_path = File.join(llp, result_file_name)
      result_mutex.synchronize do
        unless jmeter_plan_results_map.key?(master.jmeter_plan_id)
          jmeter_plan_results_map[master.jmeter_plan_id] = []
        end
        jmeter_plan_results_map[master.jmeter_plan_id].push(result_file_path)
      end
    end

    jmeter_plan_results_map.keys.sort.each do |jmeter_plan_id|
      Hailstorm::Model::ClientStat.create_client_stats(self, jmeter_plan_id,
                                                       cluster_instance,
                                                       jmeter_plan_results_map[jmeter_plan_id])
    end
  end

  # Collects the statistics generated at target_host
  # @param [Hailstorm::Model::TargetHost] target_host
  def collect_target_stats(target_host)
    logger.debug { "#{self.class}.#{__method__}" }

    # collect the remote logs
    log_file_names = target_host.download_remote_log(local_log_path)
    log_file_paths = nil
    unless log_file_names.nil?
      log_file_paths = log_file_names.collect { |n| File.join(local_log_path, n) }
    end

    Hailstorm::Model::TargetStat.create_target_stats(self, target_host, log_file_paths)
  end

  # @param [Hailstorm::Model::Project] project
  def self.create_report(project, cycle_ids)
    reported_execution_cyles = self.execution_cycles_for_report(project, cycle_ids)
    if reported_execution_cyles.empty?
      logger.warn('No results to create a report')
      return
    end

    builder = Hailstorm::Support::ReportBuilder.new
    builder.title = project.project_code.humanize

    reported_execution_cyles.each do |execution_cycle|
      builder.jmeter_plans = execution_cycle.jmeter_plans
      builder.test_summary_rows do |row|
        row.jmeter_plans = execution_cycle.jmeter_plans.collect(&:plan_name).join(', ')
        row.test_duration = execution_cycle.execution_duration
        row.total_threads_count = execution_cycle.total_threads_count
        row.target_hosts = execution_cycle.target_hosts
      end

      builder.execution_detail_items do |execution_item|
        execution_item.total_threads_count = execution_cycle.total_threads_count
        execution_cycle.clusters.each do |cluster|
          execution_item.clusters do |cluster_item|
            cluster_item.name = cluster.slug

            cluster.client_stats
                   .where(execution_cycle_id: execution_cycle.id)
                   .each do |client_stat|

              cluster_item.client_stats do |client_stat_item|
                client_stat_item.name = client_stat.jmeter_plan.plan_name
                client_stat_item.threads_count = client_stat.threads_count
                client_stat_item.aggregate_stats = client_stat.aggregate_stats
                client_stat_item.aggregate_graph do |g|
                  g.chart_model = client_stat.aggregate_graph
                end
              end
            end
          end
        end

        execution_item.hits_per_second_graph do |g|
          g.chart_model = Hailstorm::Model::ClientStat.hits_per_second_graph(execution_cycle)
        end
        execution_item.active_threads_over_time_graph do |g|
          g.chart_model = Hailstorm::Model::ClientStat.active_threads_over_time_graph(execution_cycle)
        end
        execution_item.throughput_over_time_graph do |g|
          g.chart_model = Hailstorm::Model::ClientStat.throughput_over_time_graph(execution_cycle)
        end

        execution_cycle.target_stats.each do |target_stat|
          execution_item.target_stats do |target_stat_item|
            target_stat_item.role_name = target_stat.target_host.role_name
            target_stat_item.host_name = target_stat.target_host.host_name
            target_stat_item.utilization_graph do |g|
              g.chart_model = target_stat.utilization_graph
            end
          end
        end
      end
    end

    # adding aggregate graphs over all reported_execution_cyles
    unless reported_execution_cyles.size == 1
      builder.client_comparison_graph do |graph|
        graph.chart_model = Hailstorm::Model::ClientStat.execution_comparison_graph(reported_execution_cyles)
      end

      builder.target_cpu_comparison_graph do |graph|
        graph.chart_model = Hailstorm::Model::TargetStat.cpu_comparison_graph(reported_execution_cyles)
      end
      builder.target_memory_comparison_graph do |graph|
        graph.chart_model = Hailstorm::Model::TargetStat.memory_comparison_graph(reported_execution_cyles)
      end
    end

    reports_path = File.join(Hailstorm.root, Hailstorm.reports_dir)
    timestamp = Time.now.strftime('%Y%m%d%H%M%S')
    report_file_name = "#{project.project_code}-#{timestamp}" # minus extn

    builder.build(reports_path, report_file_name) # returns path to generated file
  end

  def self.execution_cycles_for_report(project, cycle_ids = nil)
    report_sequence_list = cycle_ids
    # all stopped tests unless specific sequence is needed
    conditions = { status: States::STOPPED } if report_sequence_list.blank?
    conditions ||= { id: report_sequence_list }

    project.execution_cycles.where(conditions).order(:started_at).all
  end

  # @return [String] started_at in YYYY-MM-DD HH:MM format
  def formatted_started_at
    self.started_at.strftime('%Y-%m-%d %H:%M')
  end

  # @return [String] stopped_at in YYYY-MM-DD HH:MM format
  def formatted_stopped_at
    self.stopped_at.strftime('%Y-%m-%d %H:%M')
  end

  # @return [Integer] sum of thread_counts in client_stats for this execution_cycle
  def total_threads_count
    @total_threads_count ||= self.client_stats.sum(:threads_count)
  end

  # @return [Float] a rough cut average of 90 %tile response time across all client cycles
  def avg_90_percentile
    self.client_stats.average(:aggregate_ninety_percentile)
  end

  def avg_tps
    self.client_stats.average(:aggregate_response_throughput)
  end

  def target_hosts
    @target_hosts ||= self.target_stats.includes(:target_host).collect(&:target_host)
  end

  def clusters
    @clusters ||= self.client_stats
                      .group(:clusterable_id, :clusterable_type)
                      .select('clusterable_id, clusterable_type')
                      .order(:clusterable_type)
                      .collect { |cs| [cs.clusterable_id, cs.clusterable_type] }
                      .collect do |cs_item|

      require(cs_item.last.underscore) # require path form of the type (eg. hailstorm/model/amazon_cloud)
      clusterable_klass = cs_item.last.constantize
      clusterable_klass.find(cs_item.first) # find(id) method invoked
    end
  end

  def set_stopped_at
    self.update_attribute(:stopped_at, self.client_stats.maximum(:last_sample_at))
  end

  # @param [Time] time
  def set_started_at(time = nil)
    self.started_at = time || Time.now
  end

  # Name of all JMeter plans for this execution cycle
  # @return [Array] (of Hailstorm::Model::JmeterPlan)
  def jmeter_plans
    jmeter_plan_ids = self.client_stats.collect(&:jmeter_plan_id).uniq
    Hailstorm::Model::JmeterPlan.where(id: jmeter_plan_ids)
  end

  # The duration of the execution cycle in HH:MM:SS format. If the cycle was
  # aborted/terminated, nil is returned.
  # @return [String]
  def execution_duration
    duration = nil
    unless self.stopped_at.nil?
      duration_seconds = self.stopped_at - self.started_at
      dhc = duration_seconds / 3600 # hours component
      dhc_mod = duration_seconds % 3600
      dhm = dhc_mod / 60 # minutes component
      dhs = dhc_mod % 60 # seconds component

      duration = format('%02d:%02d:%02d', dhc, dhm, dhs)
    end

    duration
  end

  # Mark the execution cycle as stopped
  def stopped!
    self.update_attribute(:status, States::STOPPED)
  end

  # Mark the execution cycle as aborted
  def aborted!
    self.update_attribute(:status, States::ABORTED)
  end

  def terminated!
    self.update_attribute(:status, States::TERMINATED)
  end

  def reported!
    self.update_column(:status, States::REPORTED)
  end

  def excluded!
    self.update_column(:status, States::EXCLUDED)
  end

  # Exports the results as one or more JTL files
  # @@return [Array] path to the files
  def export_results
    paths = []
    export_dir = File.join(Hailstorm.root, Hailstorm.reports_dir, "SEQUENCE-#{self.id}")
    FileUtils.rm_rf(export_dir)
    FileUtils.mkpath(export_dir)
    self.client_stats.each do |cs|
      export_file_path = cs.write_jtl(export_dir)
      paths.push(export_file_path)
    end

    paths
  end

  # Import results from a JMeter results file (JTL)
  # @param [Hailstorm::Model::JmeterPlan] jmeter_plan
  # @param [Hailstorm::Behavior::Clusterable] cluster_instance
  # @param [String] result_file_path
  def import_results(jmeter_plan, cluster_instance, result_file_path)
    logger.debug { "#{self.class}.#{__method__}" }
    jmeter_plan.update_column(:latest_threads_count, jmeter_plan.num_threads)
    client_stat = Hailstorm::Model::ClientStat.create_client_stats(self, jmeter_plan.id,
                                                                   cluster_instance,
                                                                   [result_file_path],
                                                                   rm_stat_file = false)

    self.update_attributes!(started_at: client_stat.first_sample_at, stopped_at: client_stat.last_sample_at)
  end

  private

  def local_log_path
    @local_log_path ||= File.join(Hailstorm.root, Hailstorm.log_dir)
  end

  def reports_path
    File.join(Hailstorm.root, Hailstorm.reports_dir)
  end

  def set_defaults
    set_started_at
    self.status ||= States::STARTED
  end

  def visit_collection(collection, &_block)
    if collection.count == 1
      yield collection.first
    else
      collection.each do |element|
        Hailstorm::Support::Thread.start(element) do |e|
          yield e
        end
      end
      Hailstorm::Support::Thread.join
    end
  end

  class States
    STARTED = :started
    STOPPED = :stopped
    ABORTED = :aborted
    TERMINATED = :terminated
    REPORTED = :reported
    EXCLUDED = :excluded
  end
end
